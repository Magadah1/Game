std::ifstream INfile(path.toStdString());
if (!INfile)
	throw std::exception("Error in loading lvl!");
std::string tempW;

bool isNew = true;
INfile >> tempW;
if (tempW != "NEW")
	throw std::exception("Did not find field \'NEW\'!");
INfile >> isNew;

INfile >> tempW;
if (tempW != "TIME")
	throw std::exception("Did not find field \'TIME\'!");
INfile >> gameTime;

INfile >> tempW;
if (tempW != "SIZE")
	throw std::exception("Did not find field \'SIZE\'!");
size_t w, h;
INfile >> w >> h;
if (w > 20 || h > 20)
	throw std::exception("Size is too large! (Must be not greater than (20,20))");

INfile >> tempW;
if (tempW != "FIELD")
	throw std::exception("Did not find field \'FIELD\'!");

coinCount = 0;
lvl.clear();
lvlMovable.clear();
spawnPoints.clear();
enSpawnPoints.clear();
lvl.resize(w);
lvlMovable.resize(w);
for (size_t i = 0; i < w; ++i)
{
	lvl[i].resize(h);
	lvlMovable[i].resize(h);
	for (size_t j = 0; j < h; ++j)
	{
		char c;
		INfile >> c;
		if (isValidCharacter(c))
		{
			lvl[i][j] = c;
			if (c == 's')
				spawnPoints.push_back({ w - i - 1, j });
			if (c == 'e')
				enSpawnPoints.push_back({ w - i - 1, j });
			if (c == 'o')
				++coinCount;

			if (c == 'x')
				lvlMovable[i][j] = false;
			else
				lvlMovable[i][j] = true;
		}
		else
			throw std::exception("Found not valid character!");
	}
}
std::reverse(lvl.begin(), lvl.end());
std::reverse(lvlMovable.begin(), lvlMovable.end());

INfile >> tempW;
if (tempW != "PLAYER")
	throw std::exception("Did not find field \'PLAYER\'!");

int hp{}, maxhp{};
if (!isNew)
{
	INfile >> tempW;
	if (tempW != "HP")
		throw std::exception("Did not find field \'HP\'! Is it realy current state?");
	INfile >> hp;
}

INfile >> tempW;
if (tempW != "MAXHP")
	throw std::exception("Did not find field \'MAXHP\'!");
INfile >> maxhp;

size_t i{}, j{};
if (!isNew)
{
	INfile >> tempW;
	if (tempW != "POS")
		throw std::exception("Did not find field \'POS\'! Is it realy current state?");

	INfile >> i >> j;
}

INfile >> tempW;
if (tempW != "ENEMIES")
	throw std::exception("Did not find field \'ENEMIES\'!");
size_t en{};
INfile >> en;

if (en > enSpawnPoints.size())
	throw std::exception("TOO MUSH ENEMIES!");
if (!spawnPoints.size())
	throw std::exception("THERE IS NO SPAWN POINT FOR PLAYER!");

for (auto&& e : enemies)
	if (e) 
		delete e;
enemies.clear();
enemies.resize(en);


for (size_t i = 0; i < enemies.size(); ++i)
{
	INfile >> tempW;
	if (tempW != "TYPE")
		throw std::exception("Did not find field \'TYPE\'!");
	int type;
	INfile >> type;

	Enemy::ETYPE t = static_cast<Enemy::ETYPE>(type);
	if (!isNew)
	{
		INfile >> tempW;
		if (tempW != "POS")
			throw std::exception("Did not find field \'POS\'! Is it realy current state?");

		size_t ii, jj;

		INfile >> ii >> jj;
		enemies[i] = new Enemy({ static_cast<int>(ii * cellSize + cellSize / 2), static_cast<int>(jj * cellSize + cellSize / 2)}, cellSize, t);
	}
	else
	{
		enemies[i] = new Enemy({ static_cast<int>(enSpawnPoints[i].second * cellSize + cellSize / 2), static_cast<int>(enSpawnPoints[i].first * cellSize + cellSize / 2) }, cellSize, t);
	}
}

auto spawnPoint = isNew ? spawnPoints[rand() % spawnPoints.size()] : std::pair<size_t, size_t>(i, j);

if (p)
	delete p;

p = new Player({ static_cast<int>(spawnPoint.second * cellSize + cellSize / 2), static_cast<int>(spawnPoint.first * cellSize + cellSize / 2) },
	cellSize,
	(isNew ? maxhp : hp), maxhp);